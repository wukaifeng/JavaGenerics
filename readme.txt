1、泛型：参数化类型 
2、出现的动机：有很多原先促成了泛型的出现，比如集合中校验类型，防止类转换异常，其中最引人注意的一个原因是为了创建容器类
3、泛型的本质：
    1）泛型的本质就是“参数化类型”，一提到参数，最属性的时候就是定义方法时候的形参，调用方法的时候需要传递实参，参数化类型就是将原来具体的类型参数
      化。
    2）泛型的出现避免了强转的操作，在编译器完成类型转化，也避免了运行的错误。
4、泛型的目的：
  1）Java泛型也是一种语法糖，在编译阶段完成类型的转换工作，避免在运行时强制类型转换报ClassCastException异常
  
  
  泛型的三种使用方式：泛型类，泛型方法，泛型接口
2.1泛型类
    泛型类概述：把泛型定义在类上
    定义格式：
    public class 类名 <泛型类型1,...> {}   
    注意事项：泛型类型必须是引用类型（非基本数据类型）
2.2 泛型方法
  泛型方法概述：把泛型定义在方法上
  定义格式：
  public <泛型类型> 返回类型 方法名（泛型类型 变量名） {}
    注意要点：
    方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。当调用fun()方法时，
    根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。  
    
    
2.3 泛型接口
  泛型接口概述：把泛型定义在接口
  定义格式：
  public interface 接口名<泛型类型> {}   
  
  
2.5 泛型类派生子类

父类派生子类的时候不能在包含类型形参，需要传入具体的类型


2.6 泛型构造器

构造器也是一种方法，所以也就产生了所谓的泛型构造器。
和使用普通方法一样没有区别，一种是显示指定泛型参数，另一种是隐式推断
public class Person {
 public <T> Person(T t) {
 System.out.println(t);
 }
 
}
使用：

public static void main(String[] args) {
 new Person(22);// 隐式
 new <String> Person("hello");//显示
}
特殊说明：
如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。 以下面这个例子为代表
public class Person<E> {
 public <T> Person(T t) {
 System.out.println(t);
 }
}
正确用法：
public static void main(String[] args) {
 Person<String> person = new Person("sss");
}   




2.7 高级通配符

2.7.1背景：

2.7.2 <? extends T> 上界通配符

上界通配符顾名思义，<? extends T>表示的是类型的上界【包含自身】，因此通配的参数化类型可能是T或T的子类。
正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List和List是List<? extends Animal>的子类型。
它表示集合中的所有元素都是Animal类型或者其子类
 List<? extends Animal>
这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。
例如：
这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。
//Cat是其子类
 List<? extends Animal> list = new ArrayList<Cat>();
2.7.3 <? super T> 下界通配符

下界通配符<? super T>表示的是参数化类型是T的超类型（包含自身），层层至上，直至Object
编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。
 它表示集合中的所有元素都是Cat类型或者其父类
 List <? super Cat> 
这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身
例如
//Animal是其父类
List<? super Cat> list = new ArrayList<Animal>();
2.7.4 <?> 无界通配符

任意类型，如果没有明确，那么就是Object以及任意的Java类了
无界通配符用<?>表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List和List的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）

5.5 对泛型异常的限制

泛型类不能扩展 Throwable，意味着不能创建泛型异常类